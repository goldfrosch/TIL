# MVC 패턴

MVC 패턴은 Model, View, Controller로 이루어진 디자인 패턴이다.

애플리케이션의 구성 요소를 3가지 역할로 구분해 개발 프로세스에서 각각의 구성 요소에만 집중해서 개발할 수 있고,

재사용성과 확장성이 용이하다는 장점이 있다.

단점은 애플리케이션이 복잡해질수록 모델과 뷰의 관계가 복잡해진다.

## MVC 각각의 역할

### 모델

모델은 애플리케이션의 데이터(DB, 상수, 변수)를 의미한다.

사각형 모양의 박스 안에 글자가 들어있다면, 그 사각형 모양의 박스 위치 정보, 글자 내용, 글자 위치, 글자 포맷 등의 정보를 모두 가지고 있어야한다.

뷰에서 데이터를 생성하거나 수정하면 컨트롤러를 통해 모델을 생성하거나 갱신해준다.

### 뷰

뷰는 inputbox, checkbox, textarea등 사용자 인터페이스 요소를 나타낸다.

모델을 기반으로 사용자가 볼 수 있는 화면을 뜻하고 모델이 가진 정보를 따로 저장하지 않고 화면에 표시하는 정보만 가지고 있어야한다.

변경이 일어날 시 컨트롤러에 전달해야한다.

### 컨트롤러

컨트롤러는 하나 이상의 모델과 하나 이상의 뷰를 연결하는 다리 역할을 하며 이벤트 등 메인 로직을 담당한다. 모델과 뷰의 생명주기도 관리하고 변경 통지를 받으면 이를 해석해 각각 구성 요소에 해당 내용을 전달해준다.

## MVC 예시

### Spring Framework

Spring은 웹 서비스를 구축하는데 편리한 기능들을 많이 제공한단.
@RequestParam, @RequestHeader, @PathVariable 같은 어노테이션을 기반으로 사용자의 요청 값들을 쉽게 분석할 수 있고, 사용자의 어떠한 요청이 유효한 요청인지 쉽게 거를 수 있다.

### React

엄연히 말하면 React가 MVC 패턴으로 구성되어있지는 않다. MVC 패턴을 리액트로 구현이 가능하다.

## 기타 패턴

MVC에서 파생된 기타 패턴들에 대해 더 알아보자

### MVP 패턴

MVC 패턴에서 C의 컨트롤러가 P(Presenter)로 교체된 패턴이다.
MVC의 경우 컨트롤러를 통해서 모델이 업데이트 되면 뷰는 화면에 반영하고, 뷰에서 모델을 업데이트할 수 있다.
뷰에서 모델 업데이트를 한다면 또 다른 뷰가 업데이트 될 수 있는데 이렇게 하면 너무 복잡해지는 문제가 있다.

MVP 패턴은 뷰와 프레젠터를 1:1 관계로 매칭해 사용자의 Action을 뷰로 요청하고 뷰가 프레젠터를 통해 모델로 요청, 그리고 받은 데이터를 프레젠트가 뷰로 전달해주는 방식이다.

MVC와는 다르게 모델과 뷰의 의존성이 없어 복잡한 구조가 되는 문제는 해결할 수 있지만 뷰와 프레젠터의 의존성이 너무 높아지게 되는 당점이 있다.

### MVVM 패턴

MVC 패턴에서 컨트롤러가 VM(View Model)로 바뀐 패턴이다.
뷰 모델은 뷰를 더 추상화한 계층으로 MVC와는 다르게 커맨드와 데이터 바인딩을 가지는 것이 특징이다.
뷰와 뷰모델 사이의 양방향 데이터 바인딩을 지원하고, UI를 별도의 코드 수정 없이 재사용 가능하고 단위 테스팅이 쉽다.

#### 커맨드

여러 가지 요소에 대한 처리를 하나의 액션으로 처리할 수 있게 하는 기법

#### 데이터 바인딩

화면에 보이는 데이터와 웹 브라우저의 메모리 데이터를 일치시키는 기법으로, 뷰모델 변경 시 뷰가 변경된다.

### Flux 패턴

페이스북에서 MVC 모델의 단점을 보완하기 위해 사용한 아키텍쳐다.
가장 큰 특징은 단방향 데이터 흐름인데, 데이터 흐름은 항상 Action -> Dispatcher -> Store -> View -> Action -> Dispatcher -> ...

형식이다. 데이터 흐름이 항상 한방향으로 흘러 Dispatch는 Store로 Store는 View로 View는 Action으로 Action은 Dispather로 무조건 한 방향으로 흐르게해 데이터 변화를 훨씬 예측하기 더 쉽게 만들었다.

Flux는 크게 Dispatcher, Store, View 3가지로 구분된다.

#### Dispatcher

액션이 발생하면 디스패쳐로 정보가 전달되는데, 전달된 정보를 보고 등록된 콜백함수를 실행해 스토어로 데이터를 전달한다.

디스패쳐는 전체 어플리케이션에서 한개의 인스턴스만 사용한다.

#### Store

어플리케이션의 모든 상태 변경은 Store에 의해 결정되는데, 디스패쳐로 부터 메세지를 수신받기 위해서는 디스패쳐에 콜백 함수를 등록해야한다. 스토어가 변경된다면 뷰에 변경되었다는 사실을 알려주게 된다. 스토어는 싱글톤으로 관리된다.

#### View

Flux에서의 뷰는 화면에 나타내는 것 뿐만 아니라 자식 뷰로 데이터를 흘려보내는 뷰 컨트롤러 역할도 같이 수행한다.

#### Action

디스패쳐가 콜백함수를 실행해 스토어를 업데이트 시키는데 콜백 함수 실행 시 데이터가 담겨있는 객체를 전달해주는데, 이 객체가 Action이다.
